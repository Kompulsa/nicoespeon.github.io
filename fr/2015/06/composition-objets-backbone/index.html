<!DOCTYPE html><html lang="fr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, minimum-scale=1.0"><meta name="description" content="Pourquoi la composition d'objets est préférable à l'héritage en JavaScript ? Et surtout, comment applique-t-on cette idée avec Backbone ?"><meta property="og:site_name" content="@nicoespeon's blog" /><meta property="og:url" content="http://nicoespeon.com/fr/2015/06/composition-objets-backbone/" /><meta property="og:type" content="article" /><meta property="og:title" content="Héritage, composition et Backbone.js | @nicoespeon" /><meta property="og:description" content="Pourquoi la composition d'objets est préférable à l'héritage en JavaScript ? Et surtout, comment applique-t-on cette idée avec Backbone ?" /><meta property="og:image" content="http://www.gravatar.com/avatar/46978c87c5c75cea5d05a61fa8b7d95b" /><title>Héritage, composition et Backbone.js | @nicoespeon</title><link rel="icon" href="/assets/img/icon.png"><link rel="author" href="https://plus.google.com/u/0/108378377887967941980"><!-- DNS prefetch for external resources --><link rel="dns-prefetch" href="//fonts.googleapis.com"><link rel="dns-prefetch" href="//platform.twitter.com"><link rel="dns-prefetch" href="//p.twitter.com"><link rel="dns-prefetch" href="//cdn.api.twitter.com"><link rel="dns-prefetch" href="//google-analytics.com"><link rel="stylesheet"href='http://fonts.googleapis.com/css?family=Snippet|Roboto:300,100,700'><link rel="stylesheet" href="/assets/css/nicoespeon.css" media="screen"><link rel="stylesheet" href="/assets/css/nicoespeon-print.css" media="print"></head><body><div id="site"><div class="container"><div class="grid"><div class="grid__item seven-tenths portable-one-whole" role="main"><header class="media" role="banner"><!-- Brand logo --><img src="http://www.gravatar.com/avatar/46978c87c5c75cea5d05a61fa8b7d95b" class="media__img img--circle" alt="My avatar" width="80" height="80"/><!-- Main navigation --><nav class="media__body" role="navigation"><ul class="nav nav--main"><li><a href="/fr/index.html">Accueil</a></li><li><a href="/fr/about.html">À propos</a></li><li><a href="/fr/projects.html">Projets</a></li><li><a href="/fr/worth-reading.html">A Lire</a></li></ul></nav><!-- /navigation --></header><!-- /header --><article role="main"><h1>Héritage, composition et Backbone.js</h1><div class="media"><a href="https://twitter.com/share" class="twitter-share-button media__img--rev" data-text="Héritage, composition et Backbone.js |" data-via="nicoespeon">Tweeter</a><div class="media__body brand-face zeta">(19 Juin, 2015)</div></div><p class="islet">Pourquoi la composition d'objets est préférable à l'héritage en JavaScript ? Et surtout, comment applique-t-on cette idée avec Backbone ?</p><h2 id="toc_0">&quot;Favor objects composition over inheritance&quot;</h2><p>Dans la Programmation Orientée Objet (POO), on crée un certain nombre d&#39;objets avec leur structure de données et les méthodes qui composent leur interface. Pour décider de comment découper nos objets, on suit le <em>Single Responsibility Principle</em> (SRP) : <strong>chaque objet doit avoir une seule et unique raison de changer</strong>.</p><p>Pour faire des choses intéressantes, il faut combiner ces objets.</p><p>Or, en gros, il existe 2 types de relations dans le modèle objets : l&#39;héritage et la composition.</p><p>On peut faire l&#39;analogie avec un arbre généalogique :</p><ul><li><strong>l&#39;héritage</strong>, c&#39;est comme une naissance : quand ça arrive, c&#39;est pour la vie.</li><li><strong>la composition</strong> c&#39;est comme un mariage : ça arrive au cours de l&#39;existence des objets et ça peut changer. Les objets peuvent se séparer et trouver de nouveaux partenaires avec qui s&#39;associer. On notera néamoins que les objets ne sont pas monogames.</li></ul><blockquote><p>Source: <a href="http://www.amazon.com/Object-Design-Roles-Responsibilities-Collaborations/dp/0201379430">Object Design - Roles, Responsibilities and Collaborations</a></p></blockquote><h3 id="toc_1">&quot;Heritage&quot; all the things!</h3><p>Le premier réflexe des développeurs JavaScript consiste souvent à tenter de mimiquer les règles d&#39;héritage pseudo-classique.</p><p>On se retrouve alors vite avec des <code>new</code> un peu partout et des chaînes d&#39;héritage longues comme le bras. Ça produit souvent quelque chose <strong>très difficile à maintenir</strong>.</p><p>Il est vrai qu&#39;en Java on dispose de tout ce qu’il faut pour faire de l’héritage avec des classes, des interfaces, etc.</p><p>Ce n’est pas le cas en JavaScript.</p><h3 id="toc_2">Keep It Simple, Seriously</h3><p>En JavaScript, la base, c&#39;est <strong>l&#39;héritage de prototype</strong>.</p><p>Si on oublie le jargon technique, disons qu&#39;on a tout simplement <strong>des objets qui peuvent se lier à d&#39;autres objets</strong> (OLOO).</p><p>Du coup, il est vachement plus simple d&#39;encapsuler les méthodes d&#39;une même logique dans un objet, puis de simplement <strong>retourner cet objet</strong>. Au besoin, on peut aussi créer une fonction qui va retourner un objet (ce qu&#39;on appelle une <em>factory</em>).</p><p>Cet objet on va le prendre, éventuellement le composer avec d&#39;autres, pour former le prototype avec lequel on va instancier notre classe. Tout simplement.</p><p>Pour résumer : plutôt que de créer des chaînes d&#39;héritage plus ou moins bancales à grands coups de constructeurs, créez simplement vos objets et composez les pour former un prototype avec lequel vous allez instancier votre classe.</p><h2 id="toc_3">Sur un exemple concret</h2><h3 id="toc_4">Contexte</h3><p>Depuis quelques temps déjà, je travaille à temps plein sur <a href="https://beta.vinoga.com">Vinoga</a>, un jeu de social farming sur le vin, développé en HTML5.</p><p>Entre autres bibliothèques, nous utilisons <em>Backbone.js</em> pour découpler simplement nos vues de nos données.</p><p>Prenons donc un cas concret : les éléments sur la carte.</p><p>En posant les choses, on se rend vite compte qu&#39;il y a 2 types d&#39;éléments :</p><ol><li>les <code>Props</code> qui sont les éléments de décor (arbres, rochers, chemins…)</li><li>les <code>Buildings</code> qui sont les bâtiments du jeu (cuverie, château…)</li></ol><p>Une différence parmi d&#39;autres, mais notable à ce stade : les <code>Buildings</code> sont constructibles (depuis le menu de construction), les <code>Props</code> ne le sont pas (ils sont déjà sur la carte).</p><p>Quoiqu&#39;il en soit, tous les éléments partagent un comportement commun : ils sont sur la carte. Du coup, <code>Props</code> et <code>Buildings</code> dérivent tous deux de <code>Objects</code>, qui décrit le comportement d&#39;un &quot;objet&quot; sur la carte.</p><p>Mais il y a aussi différents types de <code>Buildings</code>, notamment :</p><ul><li>les <code>Markets</code> qui sont les bâtiments qui vont refléter l&#39;état de la boutique du joueur</li><li>les <code>Productions</code> qui sont les bâtiments qui vont permettre de transformer une ressource (raisin, jus) en produit (jus, bouteille)</li></ul><div class="illustration"><img alt="Héritage, niveau 1" title="Héritage, niveau 1" src="/assets/img/object-composition-backbone/1-inheritance.png">Notre chaîne d'héritage initiale</div><h3 id="toc_5">À propos de la constructibilité</h3><p>Après avoir discuté avec le Game Designer, on se rend finalement compte que les <code>Markets</code> ne sont pas constructibles : il sont déjà sur la carte de base.</p><p>La constructibilité est un comportement qui faisait partie intégrante de <code>Buildings</code> à ce stade. Mais soit, on peut se dire qu&#39;on va s&#39;en sortir facilement en changeant la chaîne d&#39;héritage ainsi :</p><div class="illustration"><img alt="Héritage, niveau 2" title="Héritage, niveau 2" src="/assets/img/object-composition-backbone/2-longuer-inheritance-chain.png">Notre chaîne d'héritage modifiée pour s'adapter</div><h3 id="toc_6">Et là, c&#39;est le drame</h3><p>Puis le temps passe, les specs évoluent et les features avec : brace yourself, <code>Decorations</code> are coming!</p><p>Les <code>Decorations</code>, ce sont des éléments de décor (des <code>Props</code>), sauf qu&#39;ils sont constructibles eux aussi !</p><p>Bon, à ce stade on est un peu coincés parce-que <code>Constructables</code> ça hérite de <code>Buildings</code>. On aimerait éviter de dupliquer <code>Constructables</code> pour recoder quasiment la même chose côté <code>Props</code>.</p><p>Dans le meilleur des scénarios, on se retrouve donc avec des classes qui héritent de propriétés inutiles.</p><div class="illustration"><img alt="Héritage, le problème" title="Héritage, le problème" src="/assets/img/object-composition-backbone/3-inheritance-issue.png">On n'a pas été très malins et on est coincés !</div><h3 id="toc_7">Why so pseudo-classical?</h3><p>Alors comment en sommes-nous arrivés là ? Comment s&#39;en sortir ?</p><p>En fait, nous nous sommes un peu précipités quand la problématique de la constructibilité est apparue. Sans plus y réfléchir nous avons tenu la logique &quot;<code>Productions</code> EST un <code>Constructables</code> qui EST un <code>Buildings</code> qui EST un <code>Objects</code>&quot;. Et PAF l&#39;héritage !</p><p>Si on y regarde mieux, la constructibilité c&#39;est un <strong>comportement</strong>. On ne peut pas dire que sans <code>Buildings</code> il n&#39;y a pas d&#39;élément <code>Constructables</code>. C&#39;est une subtilité et une erreur assez fréquente en JavaScript parce-que l&#39;héritage pseudo-classique c&#39;est la seule chose que l&#39;on retient : c&#39;est le premier (mauvais) réflexe.</p><p>Dans notre cas, la seule chaîne d&#39;héritage vraiment légitime est peut-être celle qui lie <code>Decorations</code> à <code>Props</code>. Et encore, je dis que l&#39;on peut s&#39;en passer.</p><p>En réalité, ce que l&#39;on fourre dans <code>Objects</code>, c&#39;est un ensemble de comportements qui sont communs à <code>Props</code> et <code>Buildings</code>. Mais en pratique, <code>Objects</code> ne représente rien de concret : ce serait une <em>classe abstraite</em> si nous faisions du Java. Idem pour <code>Buildings</code> ici d&#39;ailleurs.</p><h3 id="toc_8">Embrace composition</h3><p>En JavaScript, je vous suggère de le prendre autrement : décrivons chaque comportement dans un objet qui lui est propre. Laissons tomber les constructeurs et la chaîne d&#39;héritage.</p><p>Puis, combinons ces objets pour former le prototype des objets qui nous intéresse. Pas de <em>classe</em> à l&#39;horizon, simplement des objets qui <strong>se composent</strong> d&#39;autres objets. Éventuellement des <em>factories</em> pour construire le bon objet au besoin.</p><div class="illustration"><img alt="Composition, la solution" title="Composition, la solution" src="/assets/img/object-composition-backbone/4-composition-resolution.png">Il est bien plus simple de jouer aux Legos !</div><p class="islet">Dans le cas de où l'on vient augmenter notre prototype avec d'autres objets, qui décrivent des comportements, on parle alors de <strong>mixin</strong>.<br><br>Si notre objet hérite d'un autre objet, on préfèrera utiliser <strong>l'héritage de prototype</strong>.</p><h2 id="toc_9">Et avec Backbone ?</h2><h3 id="toc_10">Backbone.extend</h3><p>Quand on utilise Backbone, on se sert de <code>.extend()</code> pour surcharger <code>Backbone.[Model|Collection|View|…]</code>. Puis on l&#39;instancie avec <code>new</code>.</p><p>Du coup, il est assez fréquent de suivre le réflexe de l&#39;héritage pseudo-classique et de se retrouver avec :</p><div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">ObjectsModel</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span> <span class="err">…</span> <span class="p">);</span>
<span class="kd">var</span> <span class="nx">BuildingsModel</span> <span class="o">=</span> <span class="nx">ObjectsModel</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span> <span class="err">…</span> <span class="p">);</span>
<span class="kd">var</span> <span class="nx">MarketsModel</span> <span class="o">=</span> <span class="nx">BuildingsModel</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span> <span class="err">…</span> <span class="p">);</span>
</code></pre></div><p>Ce qui revient d&#39;ailleurs à écrire :</p><div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">MarketsModel</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="err">…</span><span class="p">).</span><span class="nx">extend</span><span class="p">(</span><span class="err">…</span><span class="p">).</span><span class="nx">extend</span><span class="p">(</span><span class="err">…</span><span class="p">);</span>

<span class="c1">// Et on instancie au besoin</span>
<span class="kd">var</span> <span class="nx">marketsModel</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MarketsModel</span><span class="p">();</span>
</code></pre></div><p>Backbone est ainsi fait et <code>.extend()</code> nous emmène très facilement sur cette pente glissante où les Models dépendent les uns des autres de manière plus ou moins subtile.</p><h3 id="toc_11">Composer son prototype PUIS étendre</h3><p>Quitte à devoir hériter de Backbone, autant limiter les dégâts. Ce n&#39;est pas parce-que <code>.extend()</code> existe que nous sommes contraints de l&#39;utiliser pour chaque objet que nous créons. Le seul objet que nous ayons à <code>.extend()</code> véritablement ici, c&#39;est <code>Backbone.Model</code>.</p><p>L&#39;idée, c&#39;est de composer des objets pour former le prototype que nous allons <strong>ensuite</strong> utiliser dans le <code>.extend()</code> de notre Model / Collection / Vue…</p><div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">objectsModelProto</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">buildingsModelProto</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">constructablesModelProto</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">};</span>

<span class="c1">// On compose pour former un nouveau prototype.</span>
<span class="kd">var</span> <span class="nx">marketsModelProto</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
  <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">},</span> <span class="c1">// -&gt; interface spécifique à markets</span>
  <span class="nx">objectsModelProto</span><span class="p">,</span>         <span class="c1">//</span>
  <span class="nx">buildingsModelProto</span><span class="p">,</span>       <span class="c1">// =&gt; nos mixins</span>
  <span class="nx">constructablesModelProto</span><span class="p">,</span>  <span class="c1">//</span>
  <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span> <span class="c1">// -&gt; pour surcharger nos mixins, si besoin</span>
<span class="p">);</span>

<span class="c1">// Une fois le prototype créé, on hérite de Backbone.</span>
<span class="kd">var</span> <span class="nx">MarketsModel</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span> <span class="nx">marketsModelProto</span> <span class="p">);</span>

<span class="c1">// Puis on instancie.</span>
<span class="kd">var</span> <span class="nx">marketsModel</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MarketsModel</span><span class="p">();</span>
</code></pre></div><p>Ici <code>objectsModelProto</code>, <code>buildingsModelProto</code> et <code>constructablesModelProto</code> viennent surcharger le prototype de base de <code>marketsModelProto</code> pour rajouter des comportements spécifiques.</p><h4 id="toc_12">Oui mais l&#39;héritage à un sens !</h4><p>Si la notion d&#39;héritage fait sens (disons que <code>Decorations</code> EST un <code>Props</code>), alors on peut tout aussi simplement utiliser <strong>l&#39;héritage de prototype</strong>.</p><p>Il s&#39;agit simplement de créer un objet à partir du prototype de <code>Props</code> en guise de prototype pour <code>Decorations</code> :</p><div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">objectsModelProto</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">};</span>
<span class="kd">var</span> <span class="nx">constructablesModelProto</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">};</span>

<span class="c1">// Props se compose avec le comportement de Objects.</span>
<span class="kd">var</span> <span class="nx">propsModelProto</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
  <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">},</span> <span class="c1">// -&gt; interface spécifique à props</span>
  <span class="nx">objectsModelProto</span>
<span class="p">);</span>

<span class="c1">// Decorations hérite de Props… et on compose le comportement</span>
<span class="c1">// de constructabilité à la volée (mixin) !</span>
<span class="kd">var</span> <span class="nx">decosModelProto</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
  <span class="nx">_</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span> <span class="nx">propsModelProto</span> <span class="p">),</span>
  <span class="nx">constructablesModelProto</span><span class="p">,</span>
  <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span> <span class="c1">// -&gt; pour surcharger nos mixins, si besoin</span>
<span class="p">);</span>

<span class="c1">// Une fois les prototype créé, on hérite de Backbone.</span>
<span class="kd">var</span> <span class="nx">PropsModel</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span> <span class="nx">propsModelProto</span> <span class="p">);</span>
<span class="kd">var</span> <span class="nx">DecorationsModel</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span> <span class="nx">decosModelProto</span> <span class="p">);</span>

<span class="c1">// Puis on instancie.</span>
<span class="kd">var</span> <span class="nx">propsModel</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PropsModel</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">decorationsModel</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DecorationsModel</span><span class="p">();</span>
</code></pre></div><p class="islet">J'utilise <code>_.assign</code> et <code>_.create</code> de <a href="https://lodash.com/" target="_blank">lodash</a> ici.<br>Il font un fallback sur <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/assign" target="_blank"><code>Object.assign()</code></a> et <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/create" target="_blank"><code>Object.create()</code></a> lorsque c'est supporté.</p><p>À noter qu&#39;il peut être intéressant d&#39;utiliser <code>_.merge</code> plutôt que <code>_.assign</code> si l&#39;on souhaite pouvoir fusionner les attributs. Ça peut être pratique avec Backbone pour fusionner certains attributs tels que <code>events</code> :</p><div class="highlight"><pre><code class="javascript"><span class="kd">var</span> <span class="nx">objectsViewProto</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">events</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">&quot;click .store&quot;</span><span class="o">:</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span>
    <span class="s2">&quot;click .turn&quot;</span><span class="o">:</span> <span class="s2">&quot;turn&quot;</span>
  <span class="p">}</span>

  <span class="nx">store</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">store</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">},</span>
  <span class="nx">turn</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">turn</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="nx">_</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
  <span class="p">{</span>
    <span class="nx">displayModal</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">displayModal</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">},</span>
    <span class="nx">select</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">select</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">objectsViewProto</span><span class="p">,</span>
  <span class="p">{</span>
    <span class="nx">events</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">&quot;click&quot;</span><span class="o">:</span> <span class="s2">&quot;select&quot;</span><span class="p">,</span>
      <span class="s2">&quot;click .turn&quot;</span><span class="o">:</span> <span class="s2">&quot;displayModal&quot;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">);</span>
<span class="c1">// -&gt;</span>
<span class="c1">// {</span>
<span class="c1">//   events: {</span>
<span class="c1">//     &quot;click&quot;: &quot;select&quot;,</span>
<span class="c1">//     &quot;click .turn&quot;: &quot;displayModal&quot;</span>
<span class="c1">//   },</span>
<span class="c1">//  </span>
<span class="c1">//   displayModal: function displayModal () { /* … */ },</span>
<span class="c1">//   select: function select () { /* … */ },</span>
<span class="c1">//   store: function store () { /* … */ },</span>
<span class="c1">//   turn: function turn () { /* … */ }</span>
<span class="c1">// }</span>

<span class="nx">_</span><span class="p">.</span><span class="nx">merge</span><span class="p">(</span>
  <span class="p">{</span>
    <span class="nx">displayModal</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">displayModal</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">},</span>
    <span class="nx">select</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">select</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">objectsViewProto</span><span class="p">,</span>
  <span class="p">{</span>
    <span class="nx">events</span><span class="o">:</span> <span class="p">{</span>
      <span class="s2">&quot;click&quot;</span><span class="o">:</span> <span class="s2">&quot;select&quot;</span><span class="p">,</span>
      <span class="s2">&quot;click .turn&quot;</span><span class="o">:</span> <span class="s2">&quot;displayModal&quot;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">);</span>
<span class="c1">// -&gt;</span>
<span class="c1">// {</span>
<span class="c1">//   events: {</span>
<span class="c1">//     &quot;click&quot;: &quot;select&quot;,</span>
<span class="c1">//     &quot;click .store&quot;: &quot;store&quot;,</span>
<span class="c1">//     &quot;click .turn&quot;: &quot;displayModal&quot;</span>
<span class="c1">//   },</span>
<span class="c1">//  </span>
<span class="c1">//   displayModal: function displayModal () { /* … */ },</span>
<span class="c1">//   select: function select () { /* … */ },</span>
<span class="c1">//   store: function store () { /* … */ },</span>
<span class="c1">//   turn: function turn () { /* … */ }</span>
<span class="c1">// }</span>
</code></pre></div><h2 id="toc_13">Pour conclure</h2><p>Préférez la <strong>composition d&#39;objets</strong> plutôt que <strong>l&#39;héritage</strong>. N&#39;utilisez l&#39;héritage que si cela fait vraiment sens, ou si c&#39;est nécessaire. Gare aux longues chaînes d&#39;héritage : c&#39;est fragile.</p><p>Ce qu&#39;il est préférable d&#39;éviter :</p><div class="highlight"><pre><code class="javascript"><span class="c1">// markets.model.js</span>
<span class="kd">var</span> <span class="nx">MarketsModel</span> <span class="o">=</span> <span class="nx">ConstructablesModel</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span> <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span> <span class="p">);</span>

<span class="c1">// main.js</span>
<span class="kd">var</span> <span class="nx">marketsModel</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MarketsModel</span><span class="p">();</span>
</code></pre></div><p>Plus flexible, plus simple :</p><div class="highlight"><pre><code class="javascript"><span class="c1">// markets.model.js</span>
<span class="kd">var</span> <span class="nx">marketsModelProto</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
  <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">},</span> <span class="c1">// -&gt; interface spécifique à markets</span>
  <span class="nx">objectsModelProto</span><span class="p">,</span>
  <span class="nx">buildingsModelProto</span><span class="p">,</span>  
  <span class="nx">constructablesModelProto</span>
<span class="p">);</span>

<span class="c1">// main.js</span>
<span class="kd">var</span> <span class="nx">MarketsModel</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span> <span class="nx">marketsModelProto</span> <span class="p">);</span>
<span class="kd">var</span> <span class="nx">marketsModel</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MarketsModel</span><span class="p">();</span>
</code></pre></div><p>Ou, dans le cas d&#39;un héritage, utiliser l&#39;héritage de prototype :</p><div class="highlight"><pre><code class="javascript"><span class="c1">// decorations.model.js</span>
<span class="kd">var</span> <span class="nx">decosModelProto</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
  <span class="nx">_</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span> <span class="nx">propsModelProto</span> <span class="p">),</span> <span class="c1">// -&gt; hérite de props</span>
  <span class="nx">constructablesModelProto</span><span class="p">,</span>
  <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span> <span class="c1">// -&gt; pour surcharger nos mixins</span>
<span class="p">);</span>

<span class="c1">// main.js</span>
<span class="kd">var</span> <span class="nx">DecorationsModel</span> <span class="o">=</span> <span class="nx">Backbone</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span> <span class="nx">decosModelProto</span> <span class="p">);</span>
<span class="kd">var</span> <span class="nx">decorationsModel</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DecorationsModel</span><span class="p">();</span>
</code></pre></div><p>Pour finir, voici quelques articles que je vous recommande pour aller plus loin sur le sujet de la composition et de l&#39;héritage en JavaScript :</p><ul><li><a href="http://www.datchley.name/understanding-prototypes-delegation-composition/">Understanding Prototypes, Delegation &amp; Composition</a> &gt; une explication de A à Z simple, claire et illustrée</li><li><a href="https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a">Common Misconceptions about Inheritance in Javascript</a> &gt; FAQ détaillée qui va au fond de la question</li></ul><div id="disqus_thread" role="complementary"></div></article></div><div class="grid__item three-tenths portable-one-whole"role="complementary"><!-- Lang navigation --><nav role="navigation"><ul class="nav nav--stacked text--center"><li ><a href="/">English version</a></li><li class="current" ><a href="/fr/">Version française</a></li></ul></nav><!-- About --><aside class="text--justify"><p>Je m'appelle <span class='brand-face'>Nicolas</span> et je suis Directeur de Production chez <a href='http://www.metidia.com'>Metidia</a>.</p><p>Je <a href='/archive'>rédige</a> des articles sur le développement web et la gestion de projets. Je suis <a href='http://www.linkedin.com/profile/view?id=143126897'>LinkedIn</a>, je <a href='https://github.com/nicoespeon/'>code</a> et je <a href='http://twitter.com/nicoespeon'>tweet</a> pas mal aussi.</p></aside><!-- RSS --><aside><p class="text--center"><a href="http://nicoespeon.com/feed.xml"><i class="icon-connection"></i>&nbsp;Restez connectés</a></p></aside><!-- Tweets --><aside class="text--center visuallyhidden--portable"><a class="twitter-timeline" href="https://twitter.com/nicoespeon" data-widget-id="320422386929377280">Tweets de @nicoespeon</a></aside><aside class="visuallyhidden--portable push--top"><h2 class="text--center">Copains</h2><a href="http://iceranking.com">IceRanking.com</a> - (SEO) Cédric Brun, Consultant en Référencement Durable</aside></div></div></div><!-- /container --></div><!-- /main-content --><footer role="contentinfo"><div class="container"><p>&copy; 2015 - <a href="https://twitter.com/nicoespeon">Nicolas (Espeon) Carlo</a><br>Ce site est construit grâce à <a href='https://github.com/mojombo/jekyll'>Jekyll</a> et à <a href='http://inuitcss.com/'>inuit.css</a> de l'excellent <a href='https://twitter.com/csswizardry'>@csswizardry</a>. Le code source est <a href='https://github.com/nicoespeon/nicoespeon.github.io'>hébergé sur GitHub</a>.</p></div></footer><!-- jQuery --><script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script>$( function () {/*** This JS code is still small so its better to keep it inline.** Only apply if we are beyond the desk CSS breakpoint on load*/if ( $( window ).width() >= 1024 ) {var $timeline = $( "ul#timeline" );/*** Then hide every label description of the timeline*/$timeline.find( "a.timeline__label" ).each( function () {$( this ).find( "p" ).hide();} );/*** And delegate the visibility effect on hover for each label description*/$timeline.on( "mouseenter mouseleave", "a.timeline__label", function () {$( this ).find( "p" ).stop().toggle( "slow" );} );}} );</script><!-- Twitter API --><script>!function ( d, s, id ) {var js, fjs = d.getElementsByTagName( s )[0];if ( !d.getElementById( id ) ) {js = d.createElement( s );js.id = id;js.src = "//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore( js, fjs );}}( document, "script", "twitter-wjs" );</script><!-- Google Analytics --><script>var _gaq = _gaq || [];_gaq.push( ['_setAccount', 'UA-39957541-2'] );_gaq.push( ['_setDomainName', 'nicoespeon.com'] );_gaq.push( ['_trackPageview'] );(function () {var ga = document.createElement( 'script' );ga.type = 'text/javascript';ga.async = true;ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';var s = document.getElementsByTagName( 'script' )[0];s.parentNode.insertBefore( ga, s );})();</script><!-- Disqus --><script>var disqus_shortname = 'nicoespeon';var disqus_url = 'http://nicoespeon.com/fr/2015/06/composition-objets-backbone/';var title = "Héritage, composition et Backbone.js";(function () {var dsq = document.createElement( 'script' );dsq.type = 'text/javascript';dsq.async = true;dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';(document.getElementsByTagName( 'head' )[0] || document.getElementsByTagName( 'body' )[0]).appendChild( dsq );})();</script><noscript>Please enable JavaScript to view the <ahref="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></body></html>